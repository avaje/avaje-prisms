package io.avaje.prism.internal;

import java.io.PrintWriter;

public class ModuleInfoReaderWriter {
  private ModuleInfoReaderWriter() {}

  public static void write(PrintWriter out, String packageName) {

    out.append(
        "package "
            + packageName
            + ";\n"
            + "\n"
            + "import static java.util.stream.Collectors.joining;\n"
            + "import static java.util.stream.Collectors.toList;\n"
            + "import static java.util.stream.Collectors.toSet;\n"
            + "\n"
            + "import java.io.IOException;\n"
            + "import java.util.ArrayList;\n"
            + "import java.util.Collection;\n"
            + "import java.util.HashSet;\n"
            + "import java.util.List;\n"
            + "import java.util.Set;\n"
            + "import java.util.TreeSet;\n"
            + "\n"
            + "import javax.annotation.processing.Generated;\n"
            + "import javax.lang.model.element.ModuleElement;\n"
            + "import javax.lang.model.element.ModuleElement.*;\n"
            + "\n"
            + "/**\n"
            + " * Helper Class to work with an application's root module-info.\n"
            + " *\n"
            + " * <p>Calling {@link ModuleElement#getDirectives()} on the application module can break compilation\n"
            + " * in some situations, so this class helps parse the module source file and get the relevant\n"
            + " * information without breaking anything.\n"
            + " */\n"
            + "@Generated(\"avaje-prism-generator\")\n"
            + "public class ModuleInfoReader {\n"
            + "\n"
            + "  private final List<RequiresDirective> requires = new ArrayList<>();\n"
            + "  private final List<UsesDirective> uses = new ArrayList<>();\n"
            + "  private final List<ExportsDirective> exports = new ArrayList<>();\n"
            + "  private final List<OpensDirective> opens = new ArrayList<>();\n"
            + "  private final List<ProvidesDirective> provides = new ArrayList<>();\n"
            + "  private final ModuleElement moduleElement;\n"
            + "  private static final Set<String> KNOWN_MODULES_ON_PATH = new HashSet<>();\n"
            + "\n"
            + "  /**\n"
            + "   * Parse the module-info.java using the ModuleElement from the APContext and create a new instance\n"
            + "   */\n"
            + "  public ModuleInfoReader() throws IOException {\n"
            + "    this(APContext.getProjectModuleElement());\n"
            + "  }\n"
            + "\n"
            + "  /**\n"
            + "   * Parse a module-info and create a new instance\n"
            + "   *\n"
            + "   * @param moduleElement the element representing the root module\n"
            + "   * @param moduleString a string containing the contents of the module-info.java\n"
            + "   */\n"
            + "  public ModuleInfoReader(ModuleElement moduleElement) {\n"
            + "    this.moduleElement = moduleElement;\n"
            + "    if (moduleElement.isUnnamed()) {\n"
            + "      return;\n"
            + "    }\n"
            + "    for (var dir : moduleElement.getDirectives()) {\n"
            + "      if (dir.getKind() == DirectiveKind.REQUIRES) {\n"
            + "        var requiresDir = (RequiresDirective) dir;\n"
            + "        requires.add(requiresDir);\n"
            + "      } else if (dir.getKind() == DirectiveKind.OPENS) {\n"
            + "        var opensDir = (ModuleElement.OpensDirective) dir;\n"
            + "        opens.add(opensDir);\n"
            + "      } else if (dir.getKind() == DirectiveKind.EXPORTS) {\n"
            + "        var exportsDir = (ModuleElement.ExportsDirective) dir;\n"
            + "        exports.add(exportsDir);\n"
            + "      } else if (dir.getKind() == DirectiveKind.PROVIDES) {\n"
            + "        var providesDir = (ModuleElement.ProvidesDirective) dir;\n"
            + "        provides.add(providesDir);\n"
            + "      } else if (dir.getKind() == DirectiveKind.USES) {\n"
            + "        var usesDir = (ModuleElement.UsesDirective) dir;\n"
            + "        uses.add(usesDir);\n"
            + "      }\n"
            + "    }\n"
            + "  }\n"
            + "\n"
            + "  /**\n"
            + "   * Check to see whether the given module is on the module path as a non-static dependency\n"
            + "   *\n"
            + "   * @param moduleName\n"
            + "   * @return whether the given module is on the path\n"
            + "   */\n"
            + "  public boolean containsOnModulePath(String moduleName) {\n"
            + "    if (requires.isEmpty()) {\n"
            + "      return false;\n"
            + "    }\n"
            + "    if (KNOWN_MODULES_ON_PATH.contains(moduleName)) {\n"
            + "      return true;\n"
            + "    }\n"
            + "    var surfaceCheck =\n"
            + "        requires.stream()\n"
            + "            .filter(r -> !r.isStatic() && r.getDependency() != null)\n"
            + "            .anyMatch(r -> r.getDependency().getQualifiedName().contentEquals(moduleName));\n"
            + "\n"
            + "    if (surfaceCheck) {\n"
            + "      return true;\n"
            + "    }\n"
            + "\n"
            + "    var seen = new HashSet<String>();\n"
            + "    return requires.stream()\n"
            + "        .filter(r -> !r.isStatic())\n"
            + "        .anyMatch(r -> hasNonStaticModule(moduleName, r.getDependency(), seen));\n"
            + "  }\n"
            + "\n"
            + "  private boolean hasNonStaticModule(String name, ModuleElement element, Set<String> seen) {\n"
            + "    if (!seen.add(element.getQualifiedName().toString())) {\n"
            + "      return false;\n"
            + "    }\n"
            + "\n"
            + "    KNOWN_MODULES_ON_PATH.add(element.getQualifiedName().toString());\n"
            + "    var directives =\n"
            + "        element.getDirectives().stream()\n"
            + "            .filter(d -> d.getKind() == DirectiveKind.REQUIRES)\n"
            + "            .map(RequiresDirective.class::cast)\n"
            + "            .filter(r -> !r.isStatic())\n"
            + "            .collect(toList());\n"
            + "    if (directives.isEmpty()) {\n"
            + "      return false;\n"
            + "    }\n"
            + "    var surfaceCheck =\n"
            + "        directives.stream().anyMatch(r -> r.getDependency().getQualifiedName().contentEquals(name));\n"
            + "\n"
            + "    if (surfaceCheck) {\n"
            + "      return true;\n"
            + "    }\n"
            + "\n"
            + "    return requires.stream().anyMatch(r -> hasNonStaticModule(name, r.getDependency(), seen));\n"
            + "  }\n"
            + "\n"
            + "  /**\n"
            + "   * Checks whether the module-info has the defined provides directive and all their implementations\n"
            + "   * Will register an error message compilation\n"
            + "   *\n"
            + "   * @param providesType the provides directive to check\n"
            + "   * @param implementations the implementations to verify the presence of\n"
            + "   */\n"
            + "  public void validateServices(String providesType, Collection<String> implementations) {\n"
            + "    if (buildPluginAvailable() || moduleElement.isUnnamed() || APContext.isTestCompilation()) {\n"
            + "      return;\n"
            + "    }\n"
            + "    final var missingImpls =\n"
            + "        new TreeSet<>(implementations).stream().collect(toSet());\n"
            + "\n"
            + "    provides()\n"
            + "        .forEach(\n"
            + "            p -> {\n"
            + "              final var contract = p.getService().getQualifiedName().toString();\n"
            + "              if (!providesType.equals(contract)) {\n"
            + "                return;\n"
            + "              }\n"
            + "              var impls = p.getImplementations();\n"
            + "              if (missingImpls.size() > impls.size()) {\n"
            + "                return;\n"
            + "              }\n"
            + "              impls.stream()\n"
            + "                  .forEach(\n"
            + "                      x -> {\n"
            + "                        missingImpls.remove(x.getQualifiedName().toString());\n"
            + "                        missingImpls.remove(APContext.elements().getBinaryName(x).toString());\n"
            + "                      });\n"
            + "            });\n"
            + "\n"
            + "    if (!missingImpls.isEmpty()) {\n"
            + "      var message = implementations.stream().collect(joining(\", \"));\n"
            + "\n"
            + "      APContext.logError(moduleElement, \"Missing `provides %s with %s;`\", providesType, message);\n"
            + "    }\n"
            + "  }\n"
            + "\n"
            + "  private static boolean buildPluginAvailable() {\n"
            + "    return isPresent(\"avaje-plugin-exists.txt\");\n"
            + "  }\n"
            + "\n"
            + "  private static boolean isPresent(String path) {\n"
            + "    try {\n"
            + "      return APContext.getBuildResource(path).toFile().exists();\n"
            + "    } catch (Exception e) {\n"
            + "      return false;\n"
            + "    }\n"
            + "  }\n"
            + "\n"
            + "  /** The requires directives associated with this module */\n"
            + "  public List<RequiresDirective> requires() {\n"
            + "    return requires;\n"
            + "  }\n"
            + "\n"
            + "  /** The uses directives associated with this module */\n"
            + "  public List<UsesDirective> uses() {\n"
            + "    return uses;\n"
            + "  }\n"
            + "\n"
            + "  /** The exports directives associated with this module */\n"
            + "  public List<ExportsDirective> exports() {\n"
            + "    return exports;\n"
            + "  }\n"
            + "\n"
            + "  /** The opens directives associated with this module */\n"
            + "  public List<OpensDirective> opens() {\n"
            + "    return opens;\n"
            + "  }\n"
            + "\n"
            + "  /** The provides directives associated with this module */\n"
            + "  public List<ProvidesDirective> provides() {\n"
            + "    return provides;\n"
            + "  }\n"
            + "}\n"
            + "");
  }
}
